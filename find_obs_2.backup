//
// Created by anna on 2/5/17.
// Edited by Chong Swee 4/2/17

/*!
 Created: Feb 5, 2017
 Finds obstacles, converts their location to (x,y) coords, and stores as object

 Identifies obstacles, find a clear path for the robot to go through
 Publishes Twist (cmd_vel) of clearest path
 Publish boolean (whether there is an obstacle within lesss than THRESHOLD_STOP)
*/



#include <string>
#include <iostream>
#include <vector>
#include "ros/ros.h"
#include "sensor_msgs/LaserScan.h"
#include "std_msgs/Bool.h"
#include "geometry_msgs/Twist.h"

#define THRESHOLD 0.5 // THRESHOLD FOR CLEAR
#define THRESHOLD_STOP 0.2 // distance whereby it should stop
#define VELOCITY 1
#define ROBO_WIDTH 0.5 // in meters

sensor_msgs::LaserScan scan;
sensor_msgs::LaserScan filtered_scan;

// ros::Publisher pub_arb;
ros::Publisher obstacle_flag;
ros::Publisher lidar_vel;

geometry_msgs::Twist twist;

void getLIDAR(const sensor_msgs::LaserScan lidar_scan)
;

void controlSpeed(const sensor_msgs::LaserScan lidar_scan)
{
    // set default speed
    twist.linear.z = VELOCITY;
    twist.angular.z = 0; // straight

    // count to contain number of obstacles
    int obs_count = 0;

    // saves last recorded distance less than threshold
    double last_obs_distance = 2 ;

    // Numer of scans > threshold
    int clear_path = 0;

    // Assign LIDAR scan to global
    scan = lidar_scan;

    // hold number of scans
    int number_of_ranges = lidar_scan.ranges.size();

    //saves the ending count of the largest clear path
    int clear_path_end_position = 0;

    // Holds the largest count for clear_path
    int largest_count = 0;

    double largest_start = 0 ;
    double largest_end = 0;

    double nearest_obs = 5.000;
    int nearest_count = 0;

    // range of lidar = 360degrees or 3.142 rad approx
    // loops through lidar
    for (int i=0; i< (number_of_ranges-1); i++){
        if (scan.ranges[i] <= nearest_obs){
          nearest_obs = scan.ranges[i];
          nearest_count = i;
        }
        // handles the number of clear path
        if(scan.ranges[i] > THRESHOLD ){
          clear_path++;
        }
        else {
          clear_path =0;
          last_obs_distance = scan.ranges[i];
        } // if more than threshold, increse path count, else reset.

        if (clear_path > largest_count){ // saves the largest clear path
          largest_count = clear_path;
          largest_start = last_obs_distance;
          largest_end = scan.ranges[i+1]; // trial
          clear_path_end_position = i;
        }
        if (scan.ranges[i]<THRESHOLD_STOP){
          obstacle_flag.publish(true);
          return;
        }
    }
    ROS_INFO("Nearest count %i", nearest_count);
    ROS_INFO("Nearest obstacle at %lf",nearest_obs);
    ROS_INFO("Clear path from count %d to %d (out of %d)",clear_path_end_position - clear_path, clear_path_end_position,number_of_ranges);
    ROS_INFO("Clear Path minimum gap distance = %f", clear_path*1.00/number_of_ranges * 3.142 * nearest_obs);
  //  ROS_INFO("Start: %f and :%f", largest_start, largest_end);

    /*
    double check =  (clear_path*scan.angle_increment)*last_obs_distance  ; // compute clear path distance ** can be modified to improve code perf

    if (check > ROBO_WIDTH){ // if distanace more than width of robot
      ROS_INFO("clear path count %d \n",clear_path);
      ROS_INFO("clear path of distance:%f \n",check);
      ROS_INFO("clear path at angle: %f\n", ((i - clear_path/2)/512)*3.142 - 3.142/2);
    }
    */

    // publish vel
    if (obs_count){
      lidar_vel.publish(twist);
    }
    else{
      twist.linear.z = VELOCITY;
      lidar_vel.publish(twist);
    }
    obstacle_flag.publish(false);
    return;
}

int main(int argc, char **argv)
{

    ros::init(argc, argv, "midbrain");

    ros::NodeHandle n;

    // create topics to publish to
    obstacle_flag = n.advertise<std_msgs::Bool>("obst/flag",1000);
    lidar_vel =n.advertise<geometry_msgs::Twist>("obst/cmd_vel", 1000);

    // subsribe to topics
    ros::Subscriber sub_lidar = n.subscribe("scan",1000,controlSpeed);

    ros::spin();

    return 0;
}
